<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    #div1 {
      width: 100px;
      height: 100px;
      border: 1px solid gray;
    }

    #div2 {
      width: 50px;
      height: 50px;
      border: 1px solid gray;
    }
  </style>
  <link rel="stylesheet" href="../../../dist/static/css/common.min.css">
</head>
<body>
<div class="pl15 pr15">
  <h1>js面向对象</h1>
  <ul>
    <li>利用元素.事件 = null ，可以清除事件</li>
    <li>e.addEvenListener("事件"，“事件处理方法”)</li>
    <li>e.target.type//获取事件目标的事件类型，返回值事件类型</li>
    <li>e.target.stopPropagation();//阻止事件的冒泡方法</li>
    <li>e.preventDefault()//清除元素的默认方法</li>
    <li>e.removeEvenlistener("事件","事件处理方法") //清除事件</li>
    <li>针对IE8和IE8以下的游览器 attchEvent detachEvent</li>
    <li>getAttribute(name) 方法通过元素节点的属性名称获取属性的值。</li>
    <li>setAttribute(name,value) 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。</li>
  </ul>
  <div id="div1">
    <div id="div2">DOM2级处理事件</div>
  </div>
  <a id="aid" href="www.baidu.com">连接百度</a>
  <button id="btn">点击</button>
  <div class="cssSwitch clearfix">
    <div class="fl w50 h50 ml10 border_1"></div>
    <div class="fl w50 h50 ml10 border_1"></div>
    <div class="fl w50 h50 ml10 border_1"></div>
    <div class="fl w50 h50 ml10 border_1"></div>
  </div>
</div>

<script>
  var div1 = document.getElementById('div1')
  var div2 = document.getElementById("div2")
  var a = document.getElementById("aid")
  div1.addEventListener("click", div1Style)
  div2.addEventListener("click", div2Style)
  div2.addEventListener("click", div3Style)
  a.addEventListener("click", aStyle)

  function div1Style () {
    this.style.background = "blue"
  }

  function div2Style (e) {
    alert(e.type)  //获取无素的事件类型
    alert(e.target.id)  //获取事件目标（元素）的ID
    e.stopPropagation()  //阻止父元素的事件冒泡
    this.style.background = "black"
  }

  function div3Style () {
    this.style.color = "red"
  }

  function aStyle (e) {
    e.preventDefault()//清除元素的默认方法
  }

  div2.removeEventListener("click", div3Style)//清除事件


  var btn = document.getElementById("btn")
  if (btn.addEventListener) {
    btn.addEventListener("click", demo)
  } else if (btn.attachEvent) {    //针对IE8 和 IE8以下的游览
    btn.attachEvent("onclick", demo)
  } else {                      //针对更老版本的游览器
    btn.onclick = demo()
  }

  function demo () {
    alert("hello")
  }

  if (btn.removeEventListener) {
    btn.removeEventListener("click", demo)
  } else if (btn.detachEvent) {    //针对IE8 和 IE8以下的游览
    btn.detachEvent("onclick", demo)
  } else {                      //针对更老版本的游览器
    btn.onclick = null
  }


  function demo1 () {
    console.log(arguments)
  }

  demo1(1, 2, 3)

  function demo2 () {
    console.log(arguments)
  }

  var arr = [1, 2, 3]
  demo2.call(demo2, 1, 2, 3)
  demo2.apply(demo2, arr)


  /**
   *  对象字面量 var object={}
   *  */
  /*对象自面量是一个表达式，这个表达式的每次运算都创建并初始化一个新对象。每次计算对象字面量的时候，
   也都会计算他的每个属性值。也就是说，如果在一个重复调用的函数中的循环体内使用了对象的自面量，
   它将创建很多新对象，并且每次创建的对象的属性值也有可能不同。*/
  /**
   * var obj = new Object();创建对象
   * */
  /*
   * var obj = new Object()   //创建了一个对象，object对象也是对象中的顶级对象
   var arry = new Array()   //创建了一个数组对象
   var date = new Date()   //创建一个时间对象
   var reg = new RegExp("js")  //创建一个正则对象
   * */

  /**
   * 通过构造函数来创建对象
   * */
  /*通过instanceof操作符可以检测一个对象是否由某个指定的构造器函数来创建的对象
   注意：
   使用的时候可以通过new操作符得到对象。
   用构造器创建对象的时候可以接收参数
   构造器函数的首首字母最好大写，区别其他的一般函数
   */

  /*
   * function Person(name,age){   //创建一个person的函数
   this.name =name;          //此处的this对应的是对象obj
   this.age = age
   }
   var obj = new Person("ziksang",21)  //用一个构造函数来创建了对象
   alert(obj.name)        //=>ziksang  用对象名.对象的属性来获得属性值
   alert(typeof obj)      //=>用typeof来检测obj是不是一个对象类型， 返回object
   alert(obj instanceof Person)  //=> 用instanceof 来检测objcet是不是person函数构造出来的对象，返回true
   * */
  /**
   * 通过object.create来创建对象
   * */
  /* var obj = Object.create({x:1})
   var obj = Object.create(null)    //创建了一个没有原型的对象，没有任何方法
   var obj = Object.create(obj.prototype) //创建了一个普通的空对象
   */

  /** delete obj.name        //用 delete加上对象.属性名 */
  /*用for in 来遍历属性*/

  /**
   * 对象的属性：
   * writable是否可写的，  表示能否修改属性的值。默认为true
   * enumerable是否可枚举的  表示能否过过for in循环返回属性是否可以枚举。
   * configurable是否可重置的， 表示是否能过来delete删除属性从来重新定义属性，能否修改其配置。
   * value 包含这个属性的数据值。读取属性值的时候，从这个位置读取。写入属性值的时候，把新值保存在这个位置。这个特性的默认值为true
   * getter  ,setter
   * obj对象本身也有三大特性    proto 原型    class 类     extensible可拓展
   原型链：  null ==>  object.prototype  ==> foo.prototype
   foo.prototype是对象上的原型 ， foo.prototype也是个对象。
   foo.prototype是对象上原型的属性  object.prototype是一个顶级属性，是所有对象的原型
   * */
  /*没有任何继续属性的话可以写  var obj = Object.create(null) 则不继承任何属性*/
  function Person () {

  }

  console.log(Person.prototype) // 是一个对象。也可以是luXu对象上的原型
  Person.prototype.name = '人类'
  var luXu = new Person() // 用构建函数来创建了luXu对象
  luXu.age = 28 // luXu 对象上本身的属性
  luXu.sex = '男' // luXu 对象上本身的属性
  console.log(luXu.age) // 对过查询对象，我们是否得到这个属性值,
  console.log(luXu.sex) // 对过查询对象，我们是否得到这个属性值,
  console.log(luXu.name) // name  luXu本身上的属性，是他原型上的属性； 如果本身没有，可以向他的原型链上的原型来查找，得到name属性
  console.log(luXu.toString()) // toString是顶级object对象上的属性，先是查找原型上有没有这个属性，如果没有再往原型链上顶级的object对象上找

  /**对象上属性的优先级
   如果在对象本身上有这个属性，则得到的是对象上本身的属性。
   如果对象本身上有这个属性，则向他的原型上查找。
   如果再没有再向顶级属性上查找。
   如果原型上和对象本身上都有这个属性，则还是先用对象本身的属性
   * */

  /** 通过In来解释某个对象上是否有这个属性 */
  console.log('name' in luXu)

  /* 通过 hasOwnProperty 查找是否是对象本身的属性，而不是继承来的属性 */
  console.log(luXu.hasOwnProperty('name'))
  console.log(luXu.hasOwnProperty('toString'))
  // propertyIsEnumerable 的意思是必是对象上的自有属性而且要以是枚举的，但是对象的可枚举属性Enumeralbe是true,才能返回true
  console.log(luXu.propertyIsEnumerable('name')) // name是Person原型上的属性，不是自有属性，则不可以枚举
  console.log(luXu.propertyIsEnumerable('age')) //  age是自有属性，可以枚举

  /** 使用FOR IN 可以枚举出自身的属性和原型上的属性 */
  for (var p in luXu) {
    console.log(p)
  }
  console.log(Object.keys(luXu))  // 使用Object.keys(luXu)只可以枚举Obj对象上自身的属性
  /** Object.getOwnPropertyNames(obj) 列出obj对象上自身的属性名 */
  console.log(Object.getOwnPropertyNames(luXu))   // Object.getOwnPropertyNames(luXu)是列出luXu对象上自身的属性名，与枚举不相关，但是又类似枚举，大家要注意区分

  /** Object.defineProperty(obj,prop,descriptor) 定义对象的属性
   obj: 需要定义的对象
   prop：需要定义 或修改的属性名
   descriptor:属性定义或修改的属性描述 {value: '', writable: false, enumerable: false, configurable: false,}
   此时定义的属性  configurable enumerable writable 默认值位 false
   */

  Object.defineProperty(luXu, 'telephone', {value: 18888888888})
  // //这个语句的意思就是在obj对象上创建了一个telephone属性，设定它的值为18888888888，
  // 对它的三大属性没有任何设置，此时三大属性为默认false
  // 此时 luXu 对象上的 telephone 这个属性不可 修改，枚举，删除
  luXu.telephone = 1999999999
  console.log(luXu.telephone) // 结果输出结果还是188....因为writable是默认值false，所以是不可修改的

  Object.defineProperty(luXu, 'address', {value: '上海', writable: true, enumerable: true, configurable: true})
  // 此时 luXu 对象上的 address 这个属性可 修改，枚举，删除

  // configurable 为false时，其它两个特性都不可以被重新定义
  // configurable 为true时，其它两个特性都可以从新定义为true

  /**用Object.defineProperties(obj, des) 一次性添加或修改多个属性的特性和值。
   * */

  Object.defineProperties(luXu, {
    firstName: {value: 'lu', writable: true, configurable: true, enumerable: true},
    lastName: {value: 'xu', configurable: true} // configurable 为true时，其它两个特性都可以从新定义为true
  })
  console.log(luXu)
  console.log(Object.getOwnPropertyDescriptor(luXu, 'firstName'))
  console.log(Object.getOwnPropertyDescriptor(luXu, 'lastName')) // {value: "xu", writable: false, enumerable: false, configurable: true}

  /** 检测对象是否是另一个对象的原型（或者处于原型链中） obj.isPrototypeOf(obj1)*/

   var luXu1 = Object.create(luXu)
  console.log(luXu.isPrototypeOf(luXu1))      //=> true  此时返回值就true，因luXu是luXu1的原型
  console.log(Object.prototype.isPrototypeOf(luXu))//=>true 因为object.prototype是顶级对象，是对象原型上的原型
  console.log(Object.prototype.isPrototypeOf(luXu1))//=>true  也是对象上的原型


  /** 对象的存储描述：get   和   set 方法 */
  /* var obj = {
   get age () {
   return 22
   },
   set age (value) {
   return value
   }
   }
   console.log('11111', obj.age)
   obj.age = 23
   console.log('22222', obj.age)*/

</script>
</body>
</html>