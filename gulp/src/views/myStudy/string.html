<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>字符串中文排序</title>
</head>
<body>
<p id="star" class="color2 f18">
  <b onclick="starFun(1)">☆</b>
  <b onclick="starFun(2)">☆</b>
  <b onclick="starFun(3)">☆</b>
  <b onclick="starFun(4)">☆</b>
  <b onclick="starFun(5)">☆</b>
</p>
<script>
  var provinceList = [
    {"code": "82", "value": "澳门"},
    {"code": "34", "value": "安徽"},
    {"code": "11", "value": "北京"},
    {"code": "50", "value": "重庆"},
    {"code": "35", "value": "福建"},
    {"code": "62", "value": "甘肃"},
    {"code": "44", "value": "广东"},
    {"code": "45", "value": "广西"},
    {"code": "52", "value": "贵州"},
    {"code": "46", "value": "海南"},
    {"code": "13", "value": "河北"},
    {"code": "41", "value": "河南"},
    {"code": "23", "value": "黑龙江"},
    {"code": "42", "value": "湖北"},
    {"code": "43", "value": "湖南"},
    {"code": "22", "value": "吉林"},
    {"code": "32", "value": "江苏"},
    {"code": "36", "value": "江西"},
    {"code": "21", "value": "辽宁"},
    {"code": "15", "value": "内蒙古"},
    {"code": "64", "value": "宁夏"},
    {"code": "63", "value": "青海"},
    {"code": "37", "value": "山东"},
    {"code": "14", "value": "山西"},
    {"code": "61", "value": "陕西"},
    {"code": "31", "value": "上海"},
    {"code": "51", "value": "四川"},
    {"code": "71", "value": "台湾"},
    {"code": "12", "value": "天津"},
    {"code": "54", "value": "西藏"},
    {"code": "81", "value": "香港"},
    {"code": "65", "value": "新疆"},
    {"code": "53", "value": "云南"},
    {"code": "33", "value": "浙江"}
  ]

  function chineseLetter (arr, dataLeven) {
    var letter = 'abcdefghjklmnopqrstwxyz'.split('')
    var zh = "阿八嚓哒妸发旮哈讥咔垃痳拏噢妑七呥扨它穵夕丫帀".split('')

    /* 获取数组元素比较的值 */
    function getValue (option) {
      if (!dataLeven) return option
      var data = option
      dataLeven.split('.').filter(function (item) {
        data = data[item]
      })
      return data + ''
    }

    /* 进行排序 */
    arr.sort(function (item1, item2) {
      return getValue(item1).localeCompare(getValue(item2), 'zh-Hans-CN')
    })
    /* 判断需要排序的字符串是否含有中文字符 */
    if (/[\u4e00-\u9fff]/.test(getValue(arr[0])) && typeof arr[0] === 'object') pySegSort(0, 0)

    /* 给省列表中添加首字符 */
    function pySegSort (letterIndex, zhIndex) {
      var first = true // 首次是否加 字母标识
      for (var i = zhIndex; i < arr.length; i++) {
        var item = arr[i]
        //      是否有值 && 当前值大于等于本次字母的最小值 && (最后一位 || 当前值小于下次字母的最小值)
        var state = zh[letterIndex] && getValue(item).localeCompare(zh[letterIndex], 'zh') >= 0 && (letterIndex === letter.length - 1 || getValue(item).localeCompare(zh[letterIndex + 1], 'zh') < 0)
        if (state) { // 满足条件，同一个首字母下的：例如 A 下的所有省份
          if (first) { //是否是第一次出现
            item.letter = letter[letterIndex].toUpperCase()
            first = false
          } else {
            item.letter = ''
          }
        } else { // 递归调用 函数，进行下次字母下的排列
          letterIndex++
          if (letterIndex < letter.length) {
            pySegSort(letterIndex, i)
            break
          }
        }
      }
    }
  }

  chineseLetter(provinceList, 'value')
  console.log(provinceList)

  var starStr = '★★★★★☆☆☆☆☆'

  function starFun (rate) {
    var str = starStr.slice(5 - rate, 10 - rate)
    document.getElementById('star').innerHTML =
        '<b onclick="starFun(1)">' + str[0] + '</b>\n' +
        '<b onclick="starFun(2)">' + str[1] + '</b>\n' +
        '<b onclick="starFun(3)">' + str[2] + '</b>\n' +
        '<b onclick="starFun(4)">' + str[3] + '</b>\n' +
        '<b onclick="starFun(5)">' + str[4] + '</b>\n'
  }
  Math.random().toString(16).substring(2)
  Math.random().toString(32).substring(2)

  console.log((10)['toString'](), (10).toString())
  /*  ~是按位取反运算，~~是取反两次
      在这里~~的作用是去掉小数部分
      因为位运算的操作值要求是整数，其结果也是整数，所以经过位运算的都会自动变成整数
      除了~~n 还可以用
      n<<0
      n>>0
      n|0 */
  var a = ~~2.33
  var b = 2.33 | 0
  var c = 2.33 >> 0
  console.log(a, b, c)
  /*
  /\B(?=(?:\d{3})+$)/g
  * 逗号替换了 \B (非文字边界，匹配位置的左右两边都是 \w）(?=(?:\d{3})+$) 里的
  * (?= ) 部分表示匹配一个位置，这个位置之后的内容符合这个括号里的条件，也就是 (?:\d{3})+
  * $(?:\d{3})+$ 表示一串长度可以被三整除的数字直至末尾
  * 如果拿这个正则表达式匹配 123456789，匹配的步骤如下：“123,456798"
  * （3 和 4 中间的位置是 \B，且之后的一串数字长度为三的倍数）"123,456,789"
  * （6 和 7 中间的位置满足）
  * */
  var num = '1256845225655.36'
  var pattern = /\B(?=(\d{3})+(?!\d))/g // 包括小数
  // var pattern = /\B(?=(?:\d{3})+$)/g // 整数
  var num1 = num.replace(pattern, ',')
  console.log(num, num1)

  // 最短的代码实现数组去重
  // ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
  var arr0 = [1, 3, 4, 3, '3', '1', 8, 90, 4]
  var arr = [...new Set(arr0)]
  console.log(arr, arr0)
// 用最短的代码实现一个长度为m(6)且值都n(8)的数组
  // ES6为Array增加了fill()函数，使用制定的元素填充数组，其实就是用默认内容初始化数组。
  /*该函数有三个参数。
  arr.fill(value, start, end)
  value：填充值。
  start：填充起始位置，可以省略。
  end：填充结束位置，可以省略，实际结束位置是end-1。*/
 console.log(Array(6).fill(8))
  // a = b || 1 <===> b ? a=b : a=1;
  // a = b && 1 <===> b ? a=1 : a=b;

  var number = [3, 5, 2, 6, 9, 56, 23]
  var maxValue = Math.max.apply(Math, number)
  var minValue = Math.min.apply(Math, number)
  console.log(maxValue, minValue)
</script>
</body>
</html>